<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>菊水楼 屋内追跡シミュレーション</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    .user-dot {
      width: 20px;
      height: 20px;
      background: red;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.5);
    }
    .notice {
      position: absolute;

      top: 10px; left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.8);
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 9999;
    }
  </style>
</head>
<body>
  <div class="notice">スマホを傾けて動かす（屋内追跡シミュレーション）</div>
  <div id="map"></div>

  <script>


    const w = 2000, h = 1200;
    const bounds = [[0,0],[h,w]];
    let map, userMarker;

    // 現在位置（初期位置）
    let pos = { x: 1000, y: 600 };
    let velocity = { x: 0, y: 0 };
    let heading = 0;

    window.onload = () => {
      // Leaflet初期化
      map = L.map('map', { crs: L.CRS.Simple, minZoom: -1 });
      L.imageOverlay('kikusui_map.png', bounds).addTo(map);
      map.fitBounds(bounds);

      // ユーザーマーカー
      userMarker = L.marker([pos.y, pos.x], {
        icon: L.divIcon({ className: 'user-dot', iconSize: [20, 20] })
      }).addTo(map);

      // スマホセンサー対応
      if (window.DeviceOrientationEvent) {
        window.addEventListener("deviceorientation", handleOrientation);
      }
      if (window.DeviceMotionEvent) {
        window.addEventListener("devicemotion", handleMotion);
      }

      // 定期的に位置更新
      setInterval(updatePosition, 100);
    };

    // 傾き（向き）を取得
    function handleOrientation(e) {
      if (e.alpha != null) {
        heading = e.alpha; // デバイスの向き（0〜360度）
      }
    }

    // 加速度から移動速度を更新
    function handleMotion(e) {
      const acc = e.accelerationIncludingGravity;
      if (!acc) return;

      // 前後方向（Y軸）の加速度で前進後退を判定
      const moveFactor = acc.y * 0.5;
      const rad = heading * Math.PI / 180;
      velocity.x += moveFactor * Math.sin(rad);
      velocity.y += moveFactor * Math.cos(rad);

      // 摩擦的に速度減衰
      velocity.x *= 0.9;
      velocity.y *= 0.9;
    }

    // マーカー位置更新
    function updatePosition() {
      pos.x += velocity.x;
      pos.y += velocity.y;

      // 境界チェック
      pos.x = Math.max(0, Math.min(w, pos.x));
      pos.y = Math.max(0, Math.min(h, pos.y));

      userMarker.setLatLng([pos.y, pos.x]);
    }
  </script>
</body>
</html>
